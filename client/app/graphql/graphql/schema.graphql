schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

"""An enumeration."""
enum ApiBlackCardPickChoices {
  """pick1"""
  A_1
  """pick2"""
  A_2
}

"""An enumeration."""
enum ApiBlackCardRatingChoices {
  """Normal"""
  NORMAL
}

"""An enumeration."""
enum ApiGameStatusChoices {
  """Gaa"""
  AWAITING_ANSWERS
  """Gac"""
  AWAITING_CZAR
  """Gap"""
  AWAITING_PLAYERS
  """Gc"""
  GAME_CANCELED
  """Ge"""
  GAME_ENDED
  """Gs"""
  GAME_STARTED
}

"""An enumeration."""
enum ApiPlayerAvatarChoices {
  """Abby"""
  ABBY
  """Alfred"""
  ALFRED
  """Andina"""
  ANDINA
  """Astro"""
  ASTRO
  """Camile"""
  CAMILE
  """Dorothy"""
  DOROTHY
  """Dudai"""
  DUDAI
  """Eduardo"""
  EDUARDO
  """General"""
  GENERAL
  """Grace"""
  GRACE
  """Iranir"""
  IRANIR
  """Jennifer"""
  JENNIFER
  """Labrat"""
  LABRAT
  """Luther"""
  LUTHER
  """Rainbowness"""
  RAINBOWNESS
  """Shin"""
  SHIN
}

"""An enumeration."""
enum ApiWhiteCardRatingChoices {
  """Normal"""
  NORMAL
}

input BatchCreateInviteInput {
  email: String!
  game: ID!
  revoked: Boolean
  spectator: Boolean
}

type BlackCardNode implements Node {
  createdAt: DateTime!
  genre: GenreNode!
  """The ID of the object."""
  id: ID!
  pick: ApiBlackCardPickChoices!
  rating: ApiBlackCardRatingChoices!
  """text allows 2-255 characters(alphabets and -,_,.,',",space)"""
  text: String!
  updatedAt: DateTime!
}

type BlackCardNodeConnection {
  edgeCount: Int
  """Contains the nodes in this connection."""
  edges: [BlackCardNodeEdge]!
  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `BlackCardNode` and its cursor."""
type BlackCardNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: BlackCardNode
}

input CreateGameInput {
  genres: [ID]!
  """seconds"""
  joinEndsAt: DateTime
  """no of players"""
  numPlayers: Int
  """no of spectators"""
  numSpectators: Int
  playerSetAdd: [CreateGameInputAddGamePlayerset]
  private: Boolean
  """seconds"""
  roundTime: Int
  """no of game rounds"""
  rounds: Int
}

input CreateGameInputAddGamePlayerset {
  avatar: ApiPlayerAvatarChoices
  spectator: Boolean
  user: ID!
  winner: [ID]
}

type CreateGameMutation {
  game: GameNode
}

input CreateGameMutationInput {
  avatar: ApiPlayerAvatarChoices!
  genres: [ID]!
  joinEndsAt: DateTime!
  numPlayers: Int!
  numSpectators: Int!
  roundTime: Int!
  rounds: Int!
  status: String!
}

type CreateNewGameMutation {
  newGame: NewGameNode
}

type CreateUserMutation {
  ok: Boolean
}

input CreateUserMutationInput {
  email: String!
  password: String!
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

input DeleteRefreshTokenCookieInput {
  clientMutationId: String
}

type DeleteRefreshTokenCookiePayload {
  clientMutationId: String
  deleted: Boolean!
}

type GameInProgressSubscription {
  gameInProgress: GameNode
}

type GameInviteMutation {
  invites: [InviteNode]
}

type GameNode implements Node {
  createdAt: DateTime!
  creator: UserNode!
  genres(after: String, before: String, credit: String, credit_Icontains: String, credit_Istartswith: String, description: String, description_Icontains: String, description_Istartswith: String, first: Int, id: Float, id_Gt: Float, id_Lt: Float, last: Int, offset: Int): GenreNodeConnection!
  """The ID of the object."""
  id: ID!
  """seconds"""
  joinEndsAt: DateTime!
  """no of players"""
  numPlayers: Int!
  """no of spectators"""
  numSpectators: Int!
  playerSet(after: String, avatar: String, before: String, createdAt: DateTime, czar: Boolean, first: Int, game: ID, last: Int, offset: Int, score: Int, spectator: Boolean, updatedAt: DateTime, user: ID): PlayerNodeConnection!
  private: Boolean!
  """seconds"""
  roundTime: Int!
  """no of game rounds"""
  rounds: Int!
  status: ApiGameStatusChoices!
  updatedAt: DateTime!
  winner: PlayerNode
}

type GameNodeConnection {
  edgeCount: Int
  """Contains the nodes in this connection."""
  edges: [GameNodeEdge]!
  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `GameNode` and its cursor."""
type GameNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: GameNode
}

type GamePrivacyMutation {
  game: GameNode
}

type GameStatusMutation {
  game: GameNode
}

type GenreNode implements Node {
  blackcardSet(after: String, before: String, createdAt: DateTime, first: Int, genre: ID, last: Int, offset: Int, pick: String, rating: String, text: String, updatedAt: DateTime): BlackCardNodeConnection!
  """credit creator(url)"""
  credit: String
  """text allows 2-255 characters(alphabets and -,_,.,',",space)"""
  description: String!
  gameSet(after: String, before: String, createdAt: DateTime, creator: ID, first: Int, genres: [ID], joinEndsAt: DateTime, last: Int, numPlayers: Int, numSpectators: Int, offset: Int, private: Boolean, roundTime: Int, rounds: Int, status: String, updatedAt: DateTime, winner: ID): GameNodeConnection!
  """The ID of the object."""
  id: ID!
  selected: Boolean
  whitecardSet(after: String, before: String, first: Int, genre: ID, last: Int, offset: Int, text: String, text_Icontains: String, text_Istartswith: String): WhiteCardNodeConnection!
}

type GenreNodeConnection {
  edgeCount: Int
  """Contains the nodes in this connection."""
  edges: [GenreNodeEdge]!
  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `GenreNode` and its cursor."""
type GenreNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: GenreNode
}

type InviteNode implements Node {
  createdAt: DateTime!
  email: String!
  game: GameNode!
  """The ID of the object."""
  id: ID!
  revoked: Boolean!
  spectator: Boolean!
  updatedAt: DateTime!
}

type InviteNodeConnection {
  edgeCount: Int
  """Contains the nodes in this connection."""
  edges: [InviteNodeEdge]!
  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `InviteNode` and its cursor."""
type InviteNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: InviteNode
}

type JWTPayloadNode {
  aud: String
  email: String
  emailVerified: Boolean
  exp: Int
  iat: Int
  iss: String
  jti: String
  name: String
  nbf: Int
  provider: String
  sub: Int
  username: String
}

type JoinGameMutation {
  ok: Boolean
  player: PlayerNode
}

input JoinGameMutationInput {
  avatar: String!
  game: ID!
  spectator: Boolean
}

"""Root Mutation for the cards against humanity api."""
type Mutation {
  createGame(input: CreateGameInput!): CreateGameMutation
  createNewGame(input: CreateGameMutationInput!): CreateNewGameMutation
  createUser(input: CreateUserMutationInput!): CreateUserMutation
  deleteRefreshTokenCookie(input: DeleteRefreshTokenCookieInput!): DeleteRefreshTokenCookiePayload
  gameInvitation(input: [BatchCreateInviteInput]!): GameInviteMutation
  gamePrivacy(id: ID!, input: UpdateGamePrivacyInput!): GamePrivacyMutation
  gameStatus(id: ID!, input: UpdateGameStatusInput!): GameStatusMutation
  joinGame(input: JoinGameMutationInput!): JoinGameMutation
  refreshToken(input: RefreshTokenMutationInput!): RefreshTokenMutationPayload
  revokeRefreshToken(input: RevokeInput!): RevokePayload
  setFullWidth(input: SetFullWidthMutationInput!): SetFullWidthMutation
  """Social Auth for JSON Web Token (JWT)"""
  socialAuth(input: SocialAuthJWTInput!): SocialAuthJWTPayload
  toggleNav: ToggleNavMutation
  tokenAuth(input: ObtainJSONWebTokenMutationInput!): ObtainJSONWebTokenMutationPayload
}

type NewGameNode {
  avatar: ApiPlayerAvatarChoices!
  genres: [ID]!
  id: ID!
  joinEndsAt: DateTime!
  numPlayers: Int!
  numSpectators: Int!
  roundTime: Int!
  rounds: Int!
  status: String!
}

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

type NotificationNode {
  """find game invites"""
  invites(after: String, before: String, createdAt: DateTime, email: String, first: Int, game: ID, last: Int, offset: Int, revoked: Boolean, spectator: Boolean, updatedAt: DateTime): InviteNodeConnection
}

type NotificationSubscription {
  message: String
  room: ID
  sender: ID
}

input ObtainJSONWebTokenMutationInput {
  clientMutationId: String
  password: String!
  username: String!
}

type ObtainJSONWebTokenMutationPayload {
  clientMutationId: String
  payload: JWTPayloadNode
  refreshExpiresIn: Int!
  refreshToken: String!
  token: String!
}

"""The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type PlayerNode implements Node {
  avatar: ApiPlayerAvatarChoices!
  createdAt: DateTime!
  czar: Boolean!
  game: GameNode!
  """The ID of the object."""
  id: ID!
  score: Int!
  spectator: Boolean!
  updatedAt: DateTime!
  user: UserNode!
  winner(after: String, before: String, createdAt: DateTime, creator: ID, first: Int, genres: [ID], joinEndsAt: DateTime, last: Int, numPlayers: Int, numSpectators: Int, offset: Int, private: Boolean, roundTime: Int, rounds: Int, status: String, updatedAt: DateTime, winner: ID): GameNodeConnection!
}

type PlayerNodeConnection {
  edgeCount: Int
  """Contains the nodes in this connection."""
  edges: [PlayerNodeEdge]!
  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `PlayerNode` and its cursor."""
type PlayerNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: PlayerNode
}

"""Root Query for the cards against humanity api."""
type Query {
  blackCards(after: String, before: String, createdAt: DateTime, first: Int, genre: ID, last: Int, offset: Int, pick: String, rating: String, text: String, updatedAt: DateTime): BlackCardNodeConnection
  """
  @client
   page is full width
  """
  fullWidth: Boolean
  game(id: ID): GameNode
  gameInProgress: GameNode
  """find games"""
  games(after: String, before: String, createdAt: DateTime, creator: ID, first: Int, genres: [ID], joinEndsAt: DateTime, last: Int, numPlayers: Int, numSpectators: Int, offset: Int, private: Boolean, roundTime: Int, rounds: Int, status: String, updatedAt: DateTime, winner: ID): GameNodeConnection
  """all cards genre"""
  genres(after: String, before: String, credit: String, credit_Icontains: String, credit_Istartswith: String, description: String, description_Icontains: String, description_Istartswith: String, first: Int, id: Float, id_Gt: Float, id_Lt: Float, last: Int, offset: Int): GenreNodeConnection
  """
  @client
   navigation sidebar open
  """
  navOpen: Boolean
  newGame(id: ID!): NewGameNode
  notifications: NotificationNode
  """find users"""
  users(after: String, before: String, createdAt: DateTime, first: Int, groups: [ID], isActive: Boolean, isAdmin: Boolean, isStaff: Boolean, isSuperuser: Boolean, last: Int, offset: Int, updatedAt: DateTime, userPermissions: [ID]): UserNodeConnection
  whiteCards(after: String, before: String, first: Int, genre: ID, last: Int, offset: Int, text: String, text_Icontains: String, text_Istartswith: String): WhiteCardNodeConnection
}

input RefreshTokenMutationInput {
  clientMutationId: String
  refreshToken: String
}

type RefreshTokenMutationPayload {
  clientMutationId: String
  payload: JWTPayloadNode
  refreshExpiresIn: Int!
  refreshToken: String!
  token: String!
}

input RevokeInput {
  clientMutationId: String
  refreshToken: String
}

type RevokePayload {
  clientMutationId: String
  revoked: Int!
}

type SetFullWidthMutation {
  fullWidth: Boolean
}

input SetFullWidthMutationInput {
  fullWidth: Boolean!
}

input SocialAuthJWTInput {
  accessToken: String!
  clientMutationId: String
  provider: String!
}

"""Social Auth for JSON Web Token (JWT)"""
type SocialAuthJWTPayload {
  clientMutationId: String
  social: SocialNode
  token: String
}

scalar SocialCamelJSON

type SocialNode implements Node {
  created: DateTime!
  extraData: SocialCamelJSON
  """The ID of the object."""
  id: ID!
  modified: DateTime!
  provider: String!
  uid: String!
  user: UserNode!
}

type SocialNodeConnection {
  """Contains the nodes in this connection."""
  edges: [SocialNodeEdge]!
  """Pagination data for this connection."""
  pageInfo: PageInfo!
}

"""A Relay edge containing a `SocialNode` and its cursor."""
type SocialNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: SocialNode
}

"""Root Subscription for the cards against humanity api."""
type Subscription {
  gameInProgress: GameInProgressSubscription
  notifications(message: String!, room: ID!, sender: ID!): NotificationSubscription
}

type ToggleNavMutation {
  navOpen: Boolean
}

input UpdateGamePrivacyInput {
  private: Boolean!
}

input UpdateGameStatusInput {
  status: ApiGameStatusChoices!
}

type UserNode implements Node {
  createdAt: DateTime!
  gameSet(after: String, before: String, createdAt: DateTime, creator: ID, first: Int, genres: [ID], joinEndsAt: DateTime, last: Int, numPlayers: Int, numSpectators: Int, offset: Int, private: Boolean, roundTime: Int, rounds: Int, status: String, updatedAt: DateTime, winner: ID): GameNodeConnection!
  """The ID of the object."""
  id: ID!
  """Active"""
  isActive: Boolean!
  """Is Admin"""
  isAdmin: Boolean!
  """Is Staff"""
  isStaff: Boolean!
  """Is Superuser"""
  isSuperuser: Boolean!
  playerSet(after: String, avatar: String, before: String, createdAt: DateTime, czar: Boolean, first: Int, game: ID, last: Int, offset: Int, score: Int, spectator: Boolean, updatedAt: DateTime, user: ID): PlayerNodeConnection!
  socialAuth(after: String, before: String, first: Int, last: Int, offset: Int, provider: String, provider_In: [String], uid: String, uid_In: [String]): SocialNodeConnection!
  updatedAt: DateTime!
}

type UserNodeConnection {
  edgeCount: Int
  """Contains the nodes in this connection."""
  edges: [UserNodeEdge]!
  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `UserNode` and its cursor."""
type UserNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: UserNode
}

type WhiteCardNode implements Node {
  createdAt: DateTime!
  genre: GenreNode!
  """The ID of the object."""
  id: ID!
  rating: ApiWhiteCardRatingChoices!
  """text allows 2-255 characters(alphabets and -,_,.,',",space)"""
  text: String!
  updatedAt: DateTime!
}

type WhiteCardNodeConnection {
  edgeCount: Int
  """Contains the nodes in this connection."""
  edges: [WhiteCardNodeEdge]!
  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `WhiteCardNode` and its cursor."""
type WhiteCardNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: WhiteCardNode
}
